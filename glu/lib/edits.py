# -*- coding: utf-8 -*-

from __future__ import division

__gluindex__  = True
__abstract__  = 'Various edit distance algorithms'
__copyright__ = 'Copyright (c) 2010, BioInformed LLC and the U.S. Department of Health & Human Services. Funded by NCI under Contract N01-CO-12400.'
__license__   = 'See GLU license for terms by running: glu license'
__revision__  = '$Id$'

import sys

import numpy as np

from   glu.lib.utils     import izip_exact


def hamming_distance(s1, s2):
  '''
  Calculate the Hamming distance between two sequences.

  This distance is the number of substitutions needed to transform the first
  sequence into the second.  Both sequences are required to be of equal
  length.

  See: http://en.wikipedia.org/wiki/Hamming_distance

  This implementation requires O(N) time and O(1) space, where N is the
  length of the input sequences.

  >>> hamming_distance('abc', 'abc')
  0
  >>> hamming_distance('abb', 'abc')
  1
  >>> hamming_distance('abc', 'def')
  3
  >>> hamming_distance('a', 'ab')
  Traceback (most recent call last):
  ...
  LengthMismatch
  '''
  return sum(ch1 != ch2 for ch1, ch2 in izip_exact(s1, s2))


def hamming_sequence(s1, s2):
  '''
  Calculate a minimum sequence of edit operations based on the
  Hamming distance between sequences.

  This distance is based on the number of substitutions needed to transform
  the first sequence into the second.  Both sequences are required to be of
  equal length.

  See: http://en.wikipedia.org/wiki/Hamming_distance

  This implementation requires O(N) time and space, where N is the length of
  the input sequences.

  >>> hamming_sequence('abc', 'abc')
  []
  >>> hamming_sequence('abb', 'abc')
  [('S', 2, 'b', 'c')]
  >>> hamming_sequence('abc', 'def')
  [('S', 0, 'a', 'd'), ('S', 1, 'b', 'e'), ('S', 2, 'c', 'f')]
  >>> hamming_sequence('a', 'ab')
  Traceback (most recent call last):
  ...
  LengthMismatch
  '''
  return [ ('S',i,c1,c2) for i,(c1,c2) in enumerate(izip_exact(s1, s2)) if c1!=c2 ]


def _edit_sequence(s1, s2, edits):
  '''
  Compute the sequence of edits required to transform sequence s1 to s2
  using the operations encoded in the supplied matrix of edit operations.
  Used internally for edit matrices generated by levenshtein_sequence and
  damerau_levenshtein_sequence
  '''
  i,j = len(s1)-1,len(s2)-1

  seq = []
  while i>=0 and j>=0:
    c1 = s1[i]
    c2 = s2[j]
    op = edits[i,j]

    if op=='M':
      if c1!=c2:
        seq.append( ('S',j,c1,c2) )
      i -= 1
      j -= 1
    elif op=='I':
      seq.append( ('I',j,c2) )
      j -= 1
    elif op=='D':
      seq.append( ('D',j,c1) )
      i -= 1
    elif op=='T':
      seq.append( ('T',j-1,s1[i-1:i+1],s2[j-1:j+1]) )
      i -= 2
      j -= 2
    else:
      raise ValueError('Invalid edit operation')

  while j>=0:
    seq.append( ('I',j,s2[j]) )
    j -= 1

  while i>=0:
    seq.append( ('D',0,s1[i]) )
    i -= 1

  seq.reverse()
  return seq


def levenshtein_distance(s1, s2):
  '''
  Calculate the Levenshtein distance between sequences.

  This distance is the number of insertions, deletions, and substitutions
  needed to transform the first sequence into the second.

  See: http://en.wikipedia.org/wiki/Levenshtein_distance

  Transpositions are exchanges of *consecutive* characters; all other
  operations are self-explanatory.

  This implementation is O(N*M) time and O(min(N,M)) space, for N and M the
  lengths of the two sequences.

  >>> levenshtein_distance('ac', 'abc')
  1
  >>> levenshtein_distance('ba', 'ab')
  2
  >>> levenshtein_distance('eat', 'seat')
  1
  >>> levenshtein_distance('abcdefghijk','cdefghijklm')
  4

  It works with arbitrary sequences too:
  >>> levenshtein_distance('abcd', ['b', 'a', 'c', 'd', 'e'])
  3
  '''
  if len(s1) < len(s2):
    s1,s2 = s2,s1

  if not s1:
    return len(s2)

  n        = len(s2)+1
  current  = range(n)
  previous = range(n)

  for i,c1 in enumerate(s1):
    previous,current = current,previous
    current[0] = i+1

    for j,c2 in enumerate(s2):
      match        = previous[j]   + (c1 != c2)
      insert       = current[j]    + 1
      delete       = previous[j+1] + 1
      current[j+1] = min(match, insert, delete)

  return current[-1]


def levenshtein_sequence(s1, s2):
  '''
  Calculate a minimum sequence of edit operations based on the
  Levenshtein distance between sequences.

  This sequence is comprised of the minimum number insertions, deletions,
  and substitutions needed to transform the first sequence into the second.

  See: http://en.wikipedia.org/wiki/Levenshtein_distance

  Transpositions are exchanges of *consecutive* characters; all other
  operations are self-explanatory.

  This implementation is O(N*M) time and O(M) space, for N and M the
  lengths of the two sequences.

  >>> levenshtein_sequence('', '')
  []
  >>> levenshtein_sequence('abc', 'abc')
  []
  >>> levenshtein_sequence('', 'abc')
  [('I', 0, 'a'), ('I', 1, 'b'), ('I', 2, 'c')]
  >>> levenshtein_sequence('abc', '')
  [('D', 0, 'a'), ('D', 0, 'b'), ('D', 0, 'c')]
  >>> levenshtein_sequence('ba', 'ab')
  [('S', 0, 'b', 'a'), ('S', 1, 'a', 'b')]
  >>> levenshtein_sequence('eat', 'seat')
  [('I', 0, 's')]
  >>> levenshtein_sequence('abcdefghijk','cdefghijklm')
  [('D', 0, 'a'), ('D', 0, 'b'), ('I', 9, 'l'), ('I', 10, 'm')]

  It works with arbitrary sequences too:
  >>> levenshtein_sequence('abcd', ['b', 'a', 'c', 'd', 'e'])
  [('S', 0, 'a', 'b'), ('S', 1, 'b', 'a'), ('I', 4, 'e')]
  '''
  if not s1:
    return [ ('I',j,c2) for j,c2 in enumerate(s2) ]

  if not s2:
    return [ ('D',0,c1) for c1 in s1 ]

  n        = len(s2)+1
  current  = range(n)
  previous = range(n)
  edits    = np.zeros((len(s1),len(s2)), dtype='S1')

  for i,c1 in enumerate(s1):
    previous,current = current,previous
    current[0] = i+1

    for j,c2 in enumerate(s2):
      match        = previous[j]   + (c1 != c2)
      insert       = current[j]    + 1
      delete       = previous[j+1] + 1
      mcost        = min(match, insert, delete)
      current[j+1] = mcost

      if mcost==match:
        edits[i,j]='M'
      elif mcost==insert:
        edits[i,j]='I'
      else:
        edits[i,j]='D'

  return _edit_sequence(s1, s2, edits)


def damerau_levenshtein_distance(s1, s2):
  '''
  Calculate the Damerau-Levenshtein distance between sequences.

  This distance is the number of insertions, deletions, substitutions, and
  transpositions needed to transform the first sequence into the second.

  See: http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance

  Transpositions are exchanges of *consecutive* characters; all other
  operations are self-explanatory.

  This implementation is O(N*M) time and O(min(N,M)) space, where N and M
  are the lengths of the two sequences.

  >>> damerau_levenshtein_distance('ba', 'ab')
  1
  >>> damerau_levenshtein_distance('ba', 'abc')
  2
  >>> damerau_levenshtein_distance('fee', 'deed')
  2
  >>> damerau_levenshtein_distance('eat', 'seat')
  1

  It works with arbitrary sequences too:
  >>> damerau_levenshtein_distance('abcd', ['b', 'a', 'c', 'd', 'e'])
  2
  '''
  if len(s1) < len(s2):
    s1,s2 = s2,s1

  if not s1:
    return len(s2)

  n         = len(s2)+1
  current   = range(n)
  previous1 = range(n)
  previous2 = range(n)

  for i,c1 in enumerate(s1):
    previous2,previous1,current = previous1,current,previous2
    current[0] = i+1

    for j,c2 in enumerate(s2):
      match  = previous1[j]   + (c1 != c2)
      insert = current[j]     + 1
      delete = previous1[j+1] + 1
      trans  = sys.maxint

      if i and j and c1==s2[j-1] and s1[i-1]==c2:
        trans = min(current[j+1], previous2[j-1]+1)

      current[j+1] = min(match, insert, delete, trans)

  return current[-1]


def damerau_levenshtein_sequence(s1, s2):
  '''
  Calculate a minimum sequence of edit operations based on the
  Damerau-Levenshtein distance between sequences.

  This sequence is comprised of the minimum number of insertions, deletions,
  substitutions, and transpositions needed to transform the first sequence
  into the second.

  See: http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance

  Transpositions are exchanges of *consecutive* characters; all other
  operations are self-explanatory.

  This implementation is O(N*M) time and O(min(N,M)) space, where N and M
  are the lengths of the two sequences.

  >>> damerau_levenshtein_sequence('ba', 'ab')
  [('T', 0, 'ba', 'ab')]
  >>> damerau_levenshtein_sequence('ba', 'abc')
  [('I', 0, 'a'), ('S', 2, 'a', 'c')]
  >>> damerau_levenshtein_sequence('fee', 'deed')
  [('S', 0, 'f', 'd'), ('I', 3, 'd')]
  >>> damerau_levenshtein_sequence('eat', 'seat')
  [('I', 0, 's')]

  It works with arbitrary sequences too:
  >>> damerau_levenshtein_sequence('abcd', ['b', 'a', 'c', 'd', 'e'])
  [('T', 0, 'ab', ['b', 'a']), ('I', 4, 'e')]
  '''
  if not s1:
    return [ ('I',j,c2) for j,c2 in enumerate(s2) ]

  if not s2:
    return [ ('D',0,c1) for c1 in s1 ]

  n         = len(s2)+1
  current   = range(n)
  previous1 = range(n)
  previous2 = range(n)
  edits     = np.zeros((len(s1),len(s2)), dtype='S1')

  for i,c1 in enumerate(s1):
    previous2,previous1,current = previous1,current,previous2
    current[0] = i+1

    for j,c2 in enumerate(s2):
      match        = previous1[j]   + (c1 != c2)
      insert       = current[j]     + 1
      delete       = previous1[j+1] + 1
      trans        = sys.maxint

      if i and j and c1==s2[j-1] and s1[i-1]==c2:
        trans      = min(current[j+1], previous2[j-1]+1)

      mcost        = min(match, insert, delete, trans)
      current[j+1] = mcost

      if mcost==match:
        edits[i,j]='M'
      elif mcost==insert:
        edits[i,j]='I'
      elif mcost==delete:
        edits[i,j]='D'
      else:
        edits[i,j]='T'

  return _edit_sequence(s1, s2, edits)


def _test():
  import doctest
  doctest.testmod()


if __name__ == '__main__':
  _test()

